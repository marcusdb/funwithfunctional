<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/night.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/monokai.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
	<style>
		.shadow {
			text-shadow: 4px 4px #000 !important;
		}
	</style>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-background="img/zwift-screen-watopia-2.jpg">
				<img src="img/zwift-primary-color.png" style="width:200px; background-color: white" />
				<h2 class="shadow">Tech Talk & Happy Hour</h2>
			</section>
			<section>
				<h2 class="shadow">Fun with Functional Reactive Programming</h2>
				<h4 class="shadow">Marcus David Bronstein @marcusdb</h4>
			</section>
			<section>
				<section>
					<blockquote cite="http://www.introtorx.com/Content/v1.0.10621.0/01_WhyRx.html#WhyRx" style="font-size:24px">
						&ldquo;Users expect real time data. They want their tweets now. Their order confirmed now. They need prices accurate as of now. Their online games need to be responsive. As a developer, you demand fire-and-forget messaging. You don't want to be blocked
						waiting for a result. You want to have the result pushed to you when it is ready. Even better, when working with result sets, you want to receive individual results as they are ready. You do not want to wait for the entire set to be processed before
						you see the first row. The world has moved to push; users are waiting for us to catch up. Developers have tools to push data, this is easy. Developers need tools to react to push data.&rdquo;
					</blockquote>
				</section>
				<section data-background='img/mind-blown.gif'></section>
				<section data-state="slideA">
					<SlideRenderer trigger="slideA"><img src="img/mind-blown.gif" /></SlideRenderer>
				</section>
			</section>

			<section id="fragments">
				<h2>Tempo real</h2>
				<p class="fragment">o que nos leva a código assíncrono</p>
				<p class="fragment">o que nos leva a callbacks??!</p>
				<aside class="notes">
					This slide has fragments which are also stepped through in the notes window.
				</aside>
			</section>
			<section>
				<h3>Código tradicional</h3>
				<div>
					<button id='btn1' style="width:60px; height: 30px; font-size: 24px">+1</button> resultado:
					<span id="result">0</span>
					<button id='btn2' style="width:60px; height: 30px; font-size: 24px">-1</button>
					<pre><code class="hljs" data-trim contenteditable>
						var total = 0;
						$('#btn1').click(() => {
							total = total + 1
							$('#result').text(total)
						});
						$('#btn2').click(() => {
							total = total - 1
							$('#result').text(total)
						});
						</code></pre>
				</div>
			</section>
			<section>
				<h3>mudando os paradigmas</h3>
				<pre class="fragment"><code class="hljs" data-trim contenteditable>
					let eventos = [+1,+1,-1,+1]
</code></pre>
				<pre class="fragment"><code class="hljs" data-trim contenteditable>
	var total = eventos.reduce(function(soma, valor) {
	  return soma + valor;
	}, 0);
</code></pre>
				<pre class="fragment"><code class="hljs" data-trim contenteditable>
$('#result').text(total)
</code></pre>
			</section>
			<section>
				<h3>stream de eventos</h3>
				<button id='example2_btn1' style="width:60px; height: 30px; font-size: 24px">+1</button>
				<pre><code class="javascript hljs" data-trim contenteditable>
						let eventStream =Rx.Observable.fromEvent($("example2_btn1"),'click')

						eventStream.do(console.log).subscribe();
					</code></pre>

			</section>
			<section id='example3'></section>
			<section id='example4'></section>
			<section id='example5'></section>
			<section id='example6'></section>
			<section id='example7'></section>
			<section id='example8'>
				Drag And Drop
        <pre><code is class="javascript hljs" data-trim contenteditable>

            let mouseup$ = Rx.Observable.fromEvent(element, 'mouseup')
            let mousemove$ = Rx.Observable.fromEvent(element, 'mousemove')
            let mousedown$ = Rx.Observable.fromEvent(element, 'mousedown').map(event => getOffset(event))
            let mousedrag$ = mousedown$.mergeMap((offsetData) =>
                mousemove$.map((position) => (calculateNewPositionWithOffset(offsetData,position)))
                .takeUntil(mouseup$)
            )
            mousedrag$.subscribe((resultPosition) => this.updatePosition(resultPosition));

        </code></pre>
        <aside class="notes">
          code pen https://codepen.io/marcusdb/pen/GEwYZd plain https://codepen.io/marcusdb/pen/rwPOEJ
        </aside>
				<div id='dragTarget' style="background-color:#f00; width: 200px; height: 200px; position: absolute; left:400px; padding:0; margin:0; cursor: 'move';">
					drag me
				</div>
			</section>
		</div>

	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>
	<script src="dist/App.js"></script>
	<script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.2/Rx.min.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			//parallaxBackgroundImage:'/img/paralax.png',
			//parallaxBackgroundSize: '2560px 1537px', // CSS syntax, e.g. "2100px 900px" - currently only pixels are supported (don't use % or auto)
			history: true,

			dependencies: [{
					src: 'plugin/markdown/marked.js'
				},
				{
					src: 'plugin/markdown/markdown.js'
				},
				{
					src: 'plugin/notes/notes.js',
					async: true
				},
				{
					src: 'plugin/highlight/highlight.js',
					async: true,
					callback: function() {
						hljs.initHighlightingOnLoad();
					}
				}
			]
		});
	</script>
	<script>
		$(function() {
			//EXAMPLE1
			var total = 0;
			$('#btn1').click(() => {
				total = total + 1
				$('#result').text(total)
			});
			$('#btn2').click(() => {
				total = total - 1
				$('#result').text(total)
			});
		});
		//EXAMPLE1 END
		//EXAMPLE2
		Rx.Observable.fromEvent($("#example2_btn1"), 'click').do(console.log).subscribe();
		//EXAMPLE2 END
		//EXAMPLE 8
		var element = document.getElementById("dragTarget");
		var getOffset = el => {
			return {
				left: el.offsetLeft,
				top: el.offsetTop
			};
			//return el.getBoundingClientRect();
		};

		let mouseup$ = Rx.Observable.fromEvent(element, "mouseup");

		let mousemove$ = Rx.Observable.fromEvent(element, "mousemove");
		let mousedown$ = Rx.Observable.fromEvent(element, "mousedown").map(event => {
			event.preventDefault();
			let offset = getOffset(element);
			console.log(offset)
			return {
				left: event.clientX - offset.left,
				top: event.clientY - offset.top
			};
		})

		let mousedrag$ = mousedown$.mergeMap(offsetData =>
			mousemove$
			.map(position => {
				return {
					left: position.clientX - offsetData.left + 'px',
					top: position.clientY - offsetData.top + 'px'
				};
			})
			.takeUntil(mouseup$)
			.do({
				complete: () => {
					console.log("done");
				}
			})
		);

		mousedrag$.subscribe(resultPosition => {

			document.getElementById("dragTarget").style.top = resultPosition.top;
			document.getElementById("dragTarget").style.left = resultPosition.left;

		});
		// EXAMPLE 8 END
	</script>
</body>

</html>
